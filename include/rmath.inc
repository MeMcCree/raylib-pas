function Clamp(value, min, max: Single): Single; cdecl; external;
function Lerp(start, endd, amount: Single): Single; cdecl; external;
function Normalize(value, start, endd: Single): Single; cdecl; external;
function Remap(value, inputStart, inputEnd, outputStart, outputEnd: Single): Single; cdecl; external;
function Wrap(value, min, max: Single): Single; cdecl; external;
function FloatEquals(x, y: Single): Integer; cdecl; external;

function Vector2Zero(): TVector2; cdecl; external;
function Vector2One(): TVector2; cdecl; external;
function Vector2Add(v1, v2: TVector2): TVector2; cdecl; external;
function Vector2AddValue(v: TVector2; add: Single): TVector2; cdecl; external;
function Vector2Subtract(v1, v2: TVector2): TVector2; cdecl; external;
function Vector2SubtractValue(v: TVector2; sub: Single): TVector2; cdecl; external;
function Vector2Length(v: TVector2): Single; cdecl; external;
function Vector2LengthSqr(v: TVector2): Single; cdecl; external;
function Vector2DotProduct(v1, v2: TVector2): Single; cdecl; external;
function Vector2Distance(v1, v2: TVector2): Single; cdecl; external;
function Vector2DistanceSqr(v1, v2: TVector2): Single; cdecl; external;
function Vector2Angle(v1, v2: TVector2): Single; cdecl; external;
function Vector2Scale(v: TVector2; scale: Single): TVector2; cdecl; external;
function Vector2Multiply(v1, v2: TVector2): TVector2; cdecl; external;
function Vector2Negate(v: TVector2): TVector2; cdecl; external;
function Vector2Divide(v1, v2: TVector2): TVector2; cdecl; external;
function Vector2Normalize(v: TVector2): TVector2; cdecl; external;
function Vector2Transform(v: TVector2; mat: TMatrix): TVector2; cdecl; external;
function Vector2Lerp(v1, v2: TVector2; amount: Single): TVector2; cdecl; external;
function Vector2Reflect(v, normal: TVector2): TVector2; cdecl; external;
function Vector2Rotate(v: TVector2; angle: Single): TVector2; cdecl; external;
function Vector2MoveTowards(v, target: TVector2; maxDistance: Single): TVector2; cdecl; external;
function Vector2Invert(v: TVector2): TVector2; cdecl; external;
function Vector2Clamp(v, min, max: TVector2): TVector2; cdecl; external;
function Vector2ClampValue(v: TVector2; min, max: Single): TVector2; cdecl; external;
function Vector2Equals(p, q: TVector2): Integer; cdecl; external;

function Vector3Zero(): TVector3; cdecl; external;
function Vector3One(): TVector3; cdecl; external;
function Vector3Add(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3AddValue(v: TVector3; add: Single): TVector3; cdecl; external;
function Vector3Subtract(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3SubtractValue(v: TVector3; sub: Single): TVector3; cdecl; external;
function Vector3Scale(v: TVector3; scalar: Single): TVector3; cdecl; external;
function Vector3Multiply(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3CrossProduct(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3Perpendicular(v: TVector3): TVector3; cdecl; external;
function Vector3Length(v: TVector3): Single; cdecl; external;
function Vector3LengthSqr(v: TVector3): Single; cdecl; external;
function Vector3DotProduct(v1, v2: TVector3): Single; cdecl; external;
function Vector3Distance(v1, v2: TVector3): Single; cdecl; external;
function Vector3DistanceSqr(v1, v2: TVector3): Single; cdecl; external;
function Vector3Angle(v1, v2: TVector3): Single; cdecl; external;
function Vector3Negate(v: TVector3): TVector3; cdecl; external;
function Vector3Divide(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3Normalize(v: TVector3): TVector3; cdecl; external;
procedure Vector3OrthoNormalize(v1, v2: PTVector3); cdecl; external;
function Vector3Transform(v: TVector3; mat: TMatrix): TVector3; cdecl; external;
function Vector3RotateByQuaternion(v: TVector3; q: TQuaternion): TVector3; cdecl; external;
function Vector3RotateByAxisAngle(v, axis: TVector3; angle: Single): TVector3; cdecl; external;
function Vector3Lerp(v1, v2: TVector3; amount: Single): TVector3; cdecl; external;
function Vector3Reflect(v, normal: TVector3): TVector3; cdecl; external;
function Vector3Min(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3Max(v1, v2: TVector3): TVector3; cdecl; external;
function Vector3Barycenter(p, a, b, c: TVector3): TVector3; cdecl; external;
function Vector3Unproject(source: TVector3; projection, view: TMatrix): TVector3; cdecl; external;
function Vector3ToFloatV(v: TVector3): TVector3; cdecl; external;
function Vector3Invert(v: TVector3): TVector3; cdecl; external;
function Vector3Clamp(v, min, max: TVector3): TVector3; cdecl; external;
function Vector3ClampValue(v: TVector3; min, max: Single): TVector3; cdecl; external;
function Vector3Equals(p, q: TVector3): Integer; cdecl; external;
function Vector3Refract(v, n: TVector3; r: Single): TVector3; cdecl; external;

function MatrixDeterminant(mat: TMatrix): Single; cdecl; external;
function MatrixTrace(mat: TMatrix): Single; cdecl; external;
function MatrixTranspose(mat: TMatrix): TMatrix; cdecl; external;
function MatrixInvert(mat: TMatrix): TMatrix; cdecl; external;
function MatrixIdentity(): TMatrix; cdecl; external;
function MatrixAdd(left, right: TMatrix): TMatrix; cdecl; external;
function MatrixSubtract(left, right: TMatrix): TMatrix; cdecl; external;
function MatrixMultiply(left, right: TMatrix): TMatrix; cdecl; external;
function MatrixTranslate(x, y, z: Single): TMatrix; cdecl; external;
function MatrixRotate(axis: TVector3; angle: Single): TMatrix; cdecl; external;
function MatrixRotateX(angle: Single): TMatrix; cdecl; external;
function MatrixRotateY(angle: Single): TMatrix; cdecl; external;
function MatrixRotateZ(angle: Single): TMatrix; cdecl; external;
function MatrixRotateXYZ(angle: TVector3): TMatrix; cdecl; external;
function MatrixRotateZYX(angle: TVector3): TMatrix; cdecl; external;
function MatrixScale(x, y, z: Single): TMatrix; cdecl; external;
function MatrixFrustum(left, right, bottom, top, near, far: Double): TMatrix; cdecl; external;
function MatrixPerspective(fovy, aspect, near, far: Double): TMatrix; cdecl; external;
function MatrixOrtho(left, right, bottom, top, near, far: Double): TMatrix; cdecl; external;
function MatrixLookAt(eye, target, up: TVector3): TMatrix; cdecl; external;
function MatrixToFloatV(mat: TMatrix): Single; cdecl; external;

function QuaternionAdd(q1, q2: TQuaternion): TQuaternion; cdecl; external;
function QuaternionAddValue(q: TQuaternion; add: Single): TQuaternion; cdecl; external;
function QuaternionSubtract(q1, q2: TQuaternion): TQuaternion; cdecl; external;
function QuaternionSubtractValue(q: TQuaternion; sub: Single): TQuaternion; cdecl; external;
function QuaternionIdentity(): TQuaternion; cdecl; external;
function QuaternionLength(q: TQuaternion): Single; cdecl; external;
function QuaternionNormalize(q: TQuaternion): TQuaternion; cdecl; external;
function QuaternionInvert(q: TQuaternion): TQuaternion; cdecl; external;
function QuaternionMultiply(q1, q2: TQuaternion): TQuaternion; cdecl; external;
function QuaternionScale(q: TQuaternion; mul: Single): TQuaternion; cdecl; external;
function QuaternionDivide(q1, q2: TQuaternion): TQuaternion; cdecl; external;
function QuaternionLerp(q1, q2: TQuaternion; amount: Single): TQuaternion; cdecl; external;
function QuaternionNlerp(q1, q2: TQuaternion; amount: Single): TQuaternion; cdecl; external;
function QuaternionSlerp(q1, q2: TQuaternion; amount: Single): TQuaternion; cdecl; external;
function QuaternionFromVector3ToVector3(from, too: TVector3): TQuaternion; cdecl; external;
function QuaternionFromMatrix(mat: TMatrix): TQuaternion; cdecl; external;
function QuaternionToMatrix(q: TQuaternion): TMatrix; cdecl; external;
function QuaternionFromAxisAngle(axis: TVector3; angle: Single): TQuaternion; cdecl; external;
procedure QuaternionToAxisAngle(q: TQuaternion; outAxis: PTVector3; outAngle: PSingle); cdecl; external;
function QuaternionFromEuler(pitch, yaw, roll: Single): TQuaternion; cdecl; external;
function QuaternionToEuler(q: TQuaternion): TVector3; cdecl; external;
function QuaternionTransform(q: TQuaternion; mat: TMatrix): TQuaternion; cdecl; external;
function QuaternionEquals(p, q: TQuaternion): Integer; cdecl; external;
// TODO